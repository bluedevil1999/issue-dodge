<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ì´ìŠˆ íšŒí”¼ 60ì´ˆ â€” HARD</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0;
      display: grid;
      place-items: center;
      height: 100vh;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Apple SD Gothic Neo", "Noto Sans KR", Arial;
      background: radial-gradient(1200px 700px at 50% 30%, rgba(120,120,255,.14), transparent 55%),
                  radial-gradient(900px 600px at 20% 80%, rgba(255,120,180,.12), transparent 55%),
                  linear-gradient(180deg, rgba(0,0,0,.06), rgba(0,0,0,.02));
    }
    .wrap { width: min(900px, 94vw); display: grid; gap: 12px; position: relative; }
    .hud { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; }
    .stats { display: flex; gap: 10px; flex-wrap: wrap; font-size: 14px; opacity: .95; }
    .pill {
      padding: 8px 10px; border-radius: 999px;
      border: 1px solid rgba(127,127,127,.35);
      backdrop-filter: blur(6px);
      background: rgba(255,255,255,.06);
    }
    .btns { display: flex; gap: 8px; }
    button {
      cursor: pointer; border: 1px solid rgba(127,127,127,.35);
      background: rgba(255,255,255,.06); color: inherit;
      border-radius: 12px; padding: 10px 12px; font-weight: 650;
      user-select: none; -webkit-tap-highlight-color: transparent;
    }
    button:hover { background: rgba(255,255,255,.10); }
    canvas {
      width: 100%;
      aspect-ratio: 16 / 9;
      border-radius: 18px;
      border: 1px solid rgba(127,127,127,.35);
      background: rgba(0,0,0,.35);
      box-shadow: 0 18px 45px rgba(0,0,0,.18);
      touch-action: none;
    }
    .help {
      font-size: 13px; opacity: .85; line-height: 1.5;
      display: flex; gap: 10px; flex-wrap: wrap; align-items: center;
    }
    kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px; padding: 2px 6px; border-radius: 6px;
      border: 1px solid rgba(127,127,127,.45);
      background: rgba(255,255,255,.06);
    }

    .touchbar {
      display: none;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
      padding: 10px;
      border: 1px solid rgba(127,127,127,.35);
      border-radius: 14px;
      background: rgba(255,255,255,.06);
      backdrop-filter: blur(6px);
    }
    .touchhint { font-size: 12px; opacity: .9; }
    .touchbtns { display: flex; gap: 8px; }
    .dashBtn { padding: 10px 14px; border-radius: 14px; font-weight: 800; }
    .dashBtn.active {
      background: rgba(255,230,160,.16);
      border-color: rgba(255,230,160,.45);
    }
    @media (max-width: 720px) {
      .hud { grid-template-columns: 1fr; }
      .btns { justify-content: flex-start; }
      .touchbar { display: flex; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="stats">
        <div class="pill">â±ï¸ ë‚¨ì€ ì‹œê°„: <span id="timeLeft">60.0</span>s</div>
        <div class="pill">ğŸƒ ì ìˆ˜: <span id="score">0</span></div>
        <div class="pill">ğŸ”¥ ë‚œì´ë„: <span id="level">1</span></div>
        <div class="pill">ğŸ’¥ í”¼ê²©: <span id="hits">0</span></div>
        <div class="pill">ğŸ¥‡ ìµœê³ : <span id="best">0</span></div>
        <div class="pill">ğŸ˜ˆ ëª¨ë“œ: HARD</div>
      </div>
      <div class="btns">
        <button id="startBtn">ì‹œì‘</button>
        <button id="restartBtn" disabled>ì¬ì‹œì‘</button>
      </div>
    </div>

    <div class="touchbar" id="touchbar">
      <div class="touchhint">ğŸ“± í„°ì¹˜: í™”ë©´ì„ <b>ë“œë˜ê·¸</b>í•´ì„œ ì´ë™</div>
      <div class="touchbtns">
        <button class="dashBtn" id="dashBtn" aria-label="dash">DASH</button>
      </div>
    </div>

    <canvas id="game" width="960" height="540"></canvas>

    <div class="help">
      PC: <kbd>â†</kbd>/<kbd>â†’</kbd> ë˜ëŠ” <kbd>A</kbd>/<kbd>D</kbd>, <kbd>Shift</kbd> ëŒ€ì‹œ, <kbd>P</kbd> ì¼ì‹œì •ì§€.
      ëª¨ë°”ì¼: ë“œë˜ê·¸ ì´ë™ + DASH ë²„íŠ¼. â˜• ë¨¹ìœ¼ë©´ 2ì´ˆ ë¬´ì .
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const ui = {
    timeLeft: document.getElementById("timeLeft"),
    score: document.getElementById("score"),
    level: document.getElementById("level"),
    hits: document.getElementById("hits"),
    best: document.getElementById("best"),
    startBtn: document.getElementById("startBtn"),
    restartBtn: document.getElementById("restartBtn"),
    dashBtn: document.getElementById("dashBtn"),
  };

  const W = canvas.width, H = canvas.height;
  const GROUND_Y = H - 44;

  const ISSUE_WORDS = [
    "ë§ˆê°", "ì‹¤ì¥ë‹˜ í˜¸ì¶œ", "ê°‘ìê¸° íšŒì˜", "ê¸´ê¸‰ ìˆ˜ì •", "ë©”ì¼ í­íƒ„", "ë¦¬ë·° ë°˜ë ¤",
    "ì´í•´ê´€ê³„ì ì¶”ê°€", "ìš”êµ¬ì‚¬í•­ ë³€ê²½", "ë°ì´í„° ì•ˆ ë§ìŒ", "ë°°í¬ ì¥ì• ", "QA ì§€ì˜¥",
    "ìƒë¬´ë‹˜ ì½”ë©˜íŠ¸", "ê³ ê°ì‚¬ í”¼ë“œë°±", "ë²”ìœ„ í™•ì¥", "ìµœì¢… ìµœì¢… ìµœì¢…", "ì˜¤ëŠ˜ê¹Œì§€",
    "ìŠ¬ë™ ë©˜ì…˜", "ê¸´ê¸‰ ê³µì§€", "ì¬ìš”ì²­", "ìš°ì„ ìˆœìœ„ ë³€ê²½"
  ];

  const WIN_TITLE = "ë‹¹ì‹ ì€ ì´ìŠˆë¥¼ ë³´ê³ ë„ ì›ƒì„ ìˆ˜ ìˆëŠ” ì‚¬ëŒ";
  const LOSE_TITLES = [
    "ğŸ’¥ ì´ìŠˆê°€ ì´ìŠˆí–ˆë‹¤",
    "ğŸ“‰ â€˜ìµœì¢… ìµœì¢…â€™ì— ë‹¹í–ˆë‹¤",
    "ğŸ§¯ ë¶ˆ ë„ëŸ¬ ê°”ë‹¤ê°€ ë¶ˆì´ ëë‹¤",
    "ğŸ§  ë‡Œ: ì²˜ë¦¬ ë¶ˆê°€ / ë§ˆìŒ: ê°•ì œ ì¢…ë£Œ",
    "ğŸš¨ ì¥ì•  ë°œìƒ: ì‚¬ëŒ(ë‚˜)",
    "ğŸ—‚ï¸ ìš”êµ¬ì‚¬í•­ ë³€ê²½ì— ì˜í•´ ì‚¬ë§",
    "ğŸ«  í‡´ê·¼ì€ í–ˆëŠ”ë°, ë‚´ ì˜í˜¼ì´ ë‚¨ì•„ìˆë‹¤",
    "ğŸ” ë‹¤ì‹œ ì‹œë„: ë‹¤ìŒë²ˆì—” ì»¤í”¼ë¥¼ ë¯¿ì",
  ];

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const rand = (a, b) => a + Math.random() * (b - a);
  const pick = (arr) => arr[(Math.random() * arr.length) | 0];

  // ===== Sound (coffee pickup) =====
  let audioCtx = null;
  function ensureAudio() {
    if (audioCtx) return;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if (!Ctx) return;
    audioCtx = new Ctx();
  }
  function beepCoffee() {
    ensureAudio();
    if (!audioCtx) return;
    if (audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});

    const t0 = audioCtx.currentTime;
    const out = audioCtx.createGain();
    out.gain.setValueAtTime(0.0001, t0);
    out.gain.exponentialRampToValueAtTime(0.20, t0 + 0.01);
    out.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.22);
    out.connect(audioCtx.destination);

    const o1 = audioCtx.createOscillator();
    const o2 = audioCtx.createOscillator();
    o1.type = "triangle";
    o2.type = "sine";
    o1.frequency.setValueAtTime(760, t0);
    o1.frequency.exponentialRampToValueAtTime(1040, t0 + 0.12);
    o2.frequency.setValueAtTime(460, t0);
    o2.frequency.exponentialRampToValueAtTime(700, t0 + 0.12);
    o1.connect(out); o2.connect(out);
    o1.start(t0); o2.start(t0);
    o1.stop(t0 + 0.23); o2.stop(t0 + 0.23);
  }

  // ===== Best score =====
  const BEST_KEY = "vibe_dodge_best_hard_v1";
  let bestScore = Number(localStorage.getItem(BEST_KEY) || "0");
  ui.best.textContent = bestScore;

  // ===== Game state =====
  const state = {
    running: false,
    paused: false,
    ended: false,
    tStart: 0,
    tPrev: 0,
    timeLimit: 60_000,
    score: 0,
    hits: 0,
    level: 1,
    shake: 0,
    slowMoUntil: 0,
    coffeeFlashUntil: 0,
  };

  const input = {
    left: false,
    right: false,
    dash: false,
    pointerActive: false,
    pointerX: W / 2,
  };

  const player = {
    x: W / 2,
    y: GROUND_Y,
    w: 34,       // HARD: í”Œë ˆì´ì–´ ì¡°ê¸ˆ ë” ì‘ê²Œ
    h: 20,
    vx: 0,
    speed: 420,
    dashSpeed: 760,
    invulnUntil: 0,
  };

  let issues = [];
  let items = [];
  let particles = [];

  function reset() {
    state.running = false;
    state.paused = false;
    state.ended = false;
    state.tStart = 0;
    state.tPrev = 0;
    state.score = 0;
    state.hits = 0;
    state.level = 1;
    state.shake = 0;
    state.slowMoUntil = 0;
    state.coffeeFlashUntil = 0;

    player.x = W / 2;
    player.vx = 0;
    player.invulnUntil = 0;

    issues = [];
    items = [];
    particles = [];

    updateUI(60_000);
    drawSplash();
  }

  function updateUI(remainingMs) {
    ui.timeLeft.textContent = (remainingMs / 1000).toFixed(1);
    ui.score.textContent = state.score;
    ui.level.textContent = state.level;
    ui.hits.textContent = state.hits;
    ui.best.textContent = bestScore;
  }

  function start() {
    if (state.running) return;
    ensureAudio();
    state.running = true;
    state.paused = false;
    state.ended = false;
    state.tStart = performance.now();
    state.tPrev = state.tStart;

    ui.startBtn.disabled = true;
    ui.restartBtn.disabled = false;

    requestAnimationFrame(loop);
  }

  function end(win) {
    state.running = false;
    state.ended = true;
    ui.startBtn.disabled = false;
    ui.restartBtn.disabled = false;

    if (state.score > bestScore) {
      bestScore = state.score;
      localStorage.setItem(BEST_KEY, String(bestScore));
    }
    drawEnd(win);
  }

  function togglePause() {
    if (!state.running) return;
    state.paused = !state.paused;
    if (!state.paused) {
      state.tPrev = performance.now();
      requestAnimationFrame(loop);
    } else {
      drawPaused();
    }
  }

  // ===== HARD: ë‚œì´ë„ ì»¤ë¸Œ (í•µì‹¬ ë³€ê²½) =====
  function computeDifficulty(elapsedMs) {
    const p = clamp(elapsedMs / state.timeLimit, 0, 1);

    // ë ˆë²¨ë„ ë” ë¹ ë¥´ê²Œ ì˜¬ë¼ê°€ê²Œ
    state.level = 1 + Math.floor(p * 11); // 1~12

    // ìŠ¤í°ë¥  ëŒ€í­ ìƒìŠ¹ (ì´ˆë°˜ë¶€í„° ì²´ê°)
    const spawnRate = 2.6 + p * 7.8;   // issues/sec : 2.6 -> 10.4

    // í™”ë©´ì— ìŒ“ì´ëŠ” ì´ìŠˆ ìˆ˜ ìƒí–¥
    const maxIssues = 16 + Math.floor(p * 28); // 16 -> 44

    // ì†ë„ ë°°ìœ¨ (í›„ë°˜ í­ì£¼)
    const speedMul = 1.25 + p * 1.15; // 1.25 -> 2.40

    // ì¢Œìš° ë“œë¦¬í”„íŠ¸ ê°•ë„
    const driftMul = 0.85 + p * 1.25; // 0.85 -> 2.10

    return { p, spawnRate, maxIssues, speedMul, driftMul };
  }

  function intersectsCircleRect(cx, cy, r, rx, ry, rw, rh) {
    const closestX = clamp(cx, rx, rx + rw);
    const closestY = clamp(cy, ry, ry + rh);
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx*dx + dy*dy) <= r*r;
  }

  function awardPoints(intensity) {
    // HARD: ì ìˆ˜ëŠ” ë” ì˜ ì˜¤ë¥´ê²Œ í•´ì„œ â€œë²„í‹´ ëŠë‚Œâ€ ìœ ì§€
    state.score += 2 + Math.floor(intensity * 4);
  }

  function hit(now) {
    // HARD: ë¬´ì  í”„ë ˆì„ ì§§ê²Œ (ì—°ì† ë§ëŠ” ê±´ ë°©ì§€í•˜ë˜, ëœ ê´€ëŒ€í•˜ê²Œ)
    if (now < player.invulnUntil) return;

    state.hits += 1;
    state.shake = 12;

    player.invulnUntil = now + 650; // ê¸°ì¡´ë³´ë‹¤ ì§§ê²Œ
    state.slowMoUntil = now + 180;  // ì‚´ì§ë§Œ

    state.score = Math.max(0, state.score - 18);
  }

  function spawnIssue(now, diff) {
    // HARD: í¬ê¸° ë²”ìœ„ + â€œì‘ê³  ë¹ ë¥¸ ë†ˆâ€ ë¹„ì¤‘ ì¦ê°€
    const smallFast = Math.random() < (0.55 + diff.p * 0.20); // í›„ë°˜ì¼ìˆ˜ë¡ ë”
    const baseR = smallFast ? rand(20, 32) : rand(28, 52);
    const r = baseR + diff.p * (smallFast ? 6 : 14);

    const x = rand(38, W - 38);
    const y = -r - rand(0, 160);

    // ì†ë„: ê¸°ë³¸ ìì²´ë„ ì˜¬ë¦¬ê³ , í›„ë°˜ speedMul ì ìš©
    const vy0 = smallFast ? rand(240, 340) : rand(190, 290);
    const vy = vy0 * diff.speedMul;

    // ì¢Œìš° ë“œë¦¬í”„íŠ¸ (ì‚¬ì¸ ê¸°ë°˜ í”ë“¤ë¦¼)
    const driftAmp = (smallFast ? rand(16, 34) : rand(20, 46)) * diff.driftMul;
    const driftSpd = rand(1.6, 3.2) + diff.p * 1.2;
    const driftPhase = rand(0, Math.PI * 2);

    issues.push({
      x, y,
      r,
      vy,
      word: pick(ISSUE_WORDS),
      rot: rand(-0.8, 0.8),
      spin: rand(-1.9, 1.9),
      touched: false,
      driftAmp,
      driftSpd,
      driftPhase,
      x0: x,
    });
  }

  function spawnCoffee(now, diff) {
    const x = rand(50, W - 50);
    const y = -40 - rand(0, 240);
    const vy = (rand(140, 210) * (1.0 + diff.p * 0.25)); // ì»¤í”¼ë„ ì¢€ ë¹¨ë¼ì§(ì¡ê¸° ì–´ë µê²Œ)
    items.push({
      kind: "coffee",
      x, y,
      r: 18,
      vy,
      rot: rand(-0.6, 0.6),
      spin: rand(-1.2, 1.2),
      taken: false,
    });
  }

  function coffeePickupFX(now, x, y) {
    beepCoffee();
    state.coffeeFlashUntil = now + 180;

    for (let i = 0; i < 18; i++) {
      particles.push({
        x, y,
        vx: rand(-200, 200),
        vy: rand(-260, 70),
        life: rand(0.35, 0.65),
        t: 0,
        r: rand(2, 4),
      });
    }
    state.shake = Math.max(state.shake, 7);
  }

  function loop(now) {
    if (!state.running || state.paused) return;

    let dt = (now - state.tPrev) / 1000;
    state.tPrev = now;
    if (now < state.slowMoUntil) dt *= 0.45;

    const elapsed = now - state.tStart;
    const remaining = Math.max(0, state.timeLimit - elapsed);
    const diff = computeDifficulty(elapsed);
    updateUI(remaining);

    // ===== HARD: ìŠ¤í° í™•ë¥  ê³„ì‚° ê°œì„  (í”„ë ˆì„ dtì— ê°•í•¨) =====
    // Poisson-ish: dtê°€ ì»¤ì ¸ë„ ì¼ì •í•˜ê²Œ
    const expected = diff.spawnRate * dt;
    let spawnCount = Math.floor(expected);
    if (Math.random() < (expected - spawnCount)) spawnCount++;

    // ì´ˆë°˜ì—ë„ ëª°ì•„ì¹˜ê²Œ: ì•½ê°„ì˜ ë²„ìŠ¤íŠ¸
    if (Math.random() < (0.12 + diff.p * 0.08)) spawnCount++;

    // maxIssues ì•ˆì—ì„œë§Œ
    const room = Math.max(0, diff.maxIssues - issues.length);
    spawnCount = Math.min(spawnCount, room, 6); // í•œ í”„ë ˆì„ ìµœëŒ€ 6ê°œ

    for (let i = 0; i < spawnCount; i++) {
      spawnIssue(now, diff);
    }

    // ===== HARD: ì»¤í”¼ ë” í¬ê·€ =====
    const coffeeProb = (0.09 + diff.p * 0.06) * dt; // ëŒ€í­ ê°ì†Œ
    if (items.length < 1 && Math.random() < coffeeProb) {
      spawnCoffee(now, diff);
    }

    // ===== movement =====
    const targetSpeed = (input.dash ? player.dashSpeed : player.speed);

    if (input.pointerActive) {
      const dx = input.pointerX - player.x;
      const step = clamp(dx, -targetSpeed * dt, targetSpeed * dt);
      player.x += step;
      player.vx = step / dt;
    } else {
      let ax = 0;
      if (input.left) ax -= 1;
      if (input.right) ax += 1;
      player.vx = ax * targetSpeed;
      player.x += player.vx * dt;
    }
    player.x = clamp(player.x, 22, W - 22);

    // ===== update issues/items =====
    for (const it of issues) {
      it.y += it.vy * dt;
      it.rot += it.spin * dt;

      // HARD: drift ì ìš©
      const t = now / 1000;
      it.x = it.x0 + Math.sin(it.driftPhase + t * it.driftSpd) * it.driftAmp;
      it.x = clamp(it.x, 26, W - 26);
    }

    for (const it of items) {
      it.y += it.vy * dt;
      it.rot += it.spin * dt;
    }

    // particles
    particles = particles.filter(p => (p.t += dt) < p.life);
    for (const p of particles) {
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 420 * dt;
    }

    // collisions
    const rx = player.x - player.w/2;
    const ry = player.y - player.h/2;
    const rw = player.w, rh = player.h;

    for (const it of issues) {
      if (!it.touched && intersectsCircleRect(it.x, it.y, it.r * 0.85, rx, ry, rw, rh)) {
        it.touched = true;
        hit(now);
      }
    }

    for (const it of items) {
      if (it.kind === "coffee" && !it.taken &&
          intersectsCircleRect(it.x, it.y, it.r * 0.95, rx, ry, rw, rh)) {
        it.taken = true;
        player.invulnUntil = Math.max(player.invulnUntil, now + 2000);
        coffeePickupFX(now, it.x, it.y);
      }
    }

    // cleanup
    issues = issues.filter(it => it.y < H + it.r + 120);
    items = items.filter(it => !it.taken && it.y < H + it.r + 120);

    // score
    awardPoints(diff.p);

    // render
    render(now, diff.p);

    // end
    if (remaining <= 0) return end(true);
    if (state.hits >= 6) return end(false);

    requestAnimationFrame(loop);
  }

  // ===== Office illustration background (same vibe) =====
  function drawOfficeBackground(now) {
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, "rgba(70,110,210,0.55)");
    g.addColorStop(0.55, "rgba(120,200,255,0.18)");
    g.addColorStop(1, "rgba(20,20,30,0.45)");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);

    if (now < state.coffeeFlashUntil) {
      ctx.fillStyle = "rgba(255,230,160,0.10)";
      ctx.fillRect(0, 0, W, H);
    }

    ctx.save();
    ctx.globalAlpha = 0.85;
    const winY = 62, winH = 170;
    for (let i = 0; i < 3; i++) {
      const x = 90 + i * 270;
      roundRectPath(x, winY, 230, winH, 18);
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.save();
      ctx.beginPath();
      roundRectPath(x+10, winY+10, 210, winH-20, 14);
      ctx.clip();

      const base = winY + winH - 12;
      ctx.fillStyle = "rgba(0,0,0,0.20)";
      for (let b = 0; b < 14; b++) {
        const bx = x + 10 + b * 18 + rand(-2, 2);
        const bw = rand(10, 20);
        const bh = rand(30, 110);
        ctx.fillRect(bx, base - bh, bw, bh);
      }

      const t = (now / 1000);
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      for (let c = 0; c < 4; c++) {
        const cx = x + 20 + ((t*18 + c*80) % 260);
        const cy = winY + 26 + c * 22;
        ctx.beginPath();
        ctx.ellipse(cx, cy, 26, 10, 0, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }
    ctx.restore();

    ctx.save();
    const deskY = H - 150;
    ctx.fillStyle = "rgba(15,15,22,0.55)";
    ctx.fillRect(0, deskY, W, 150);
    ctx.fillStyle = "rgba(255,255,255,0.05)";
    ctx.fillRect(0, deskY, W, 3);
    drawMonitor(160, deskY + 38, 210, 110);
    drawMonitor(430, deskY + 30, 260, 130);
    drawMonitor(730, deskY + 44, 180, 95);
    drawPaper(300, deskY + 112, 90, 52, -0.14);
    drawPaper(590, deskY + 118, 110, 58, 0.10);
    drawPlant(820, deskY + 120);
    drawDeskMug(90, deskY + 118);
    ctx.restore();
  }

  function drawMonitor(x, y, w, h) {
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    roundRectPath(x + w*0.42, y + h + 6, w*0.16, 20, 8);
    ctx.fill();
    ctx.fillRect(x + w*0.35, y + h + 22, w*0.30, 6);
    roundRectPath(x, y, w, h, 16);
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.20)";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.save();
    ctx.beginPath();
    roundRectPath(x+10, y+10, w-20, h-20, 12);
    ctx.clip();
    const gg = ctx.createLinearGradient(x, y, x+w, y+h);
    gg.addColorStop(0, "rgba(120,170,255,0.18)");
    gg.addColorStop(1, "rgba(255,120,180,0.10)");
    ctx.fillStyle = gg;
    ctx.fillRect(x+10, y+10, w-20, h-20);
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    for (let i=0;i<6;i++) ctx.fillRect(x+20, y+24+i*14, w-60, 6);
    ctx.fillStyle = "rgba(255,230,160,0.12)";
    ctx.fillRect(x+20, y+h-42, w-90, 10);
    ctx.restore();
    ctx.restore();
  }

  function drawPaper(x, y, w, h, rot) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rot);
    roundRectPath(-w/2, -h/2, w, h, 10);
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.fillStyle = "rgba(255,255,255,0.12)";
    for (let i=0;i<4;i++) ctx.fillRect(-w/2+10, -h/2+12+i*10, w-20, 4);
    ctx.restore();
  }

  function drawPlant(x, y) {
    ctx.save();
    roundRectPath(x-22, y-14, 44, 28, 10);
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1.5;
    ctx.stroke();

    ctx.fillStyle = "rgba(120,255,180,0.10)";
    ctx.strokeStyle = "rgba(120,255,180,0.20)";
    ctx.lineWidth = 2;
    for (let i=0;i<6;i++){
      ctx.beginPath();
      ctx.moveTo(x, y-14);
      ctx.quadraticCurveTo(x-24+ i*8, y-55 - (i%2)*10, x-6+i*2, y-24);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawDeskMug(x, y) {
    ctx.save();
    roundRectPath(x-18, y-18, 36, 36, 12);
    ctx.fillStyle = "rgba(255,230,160,0.10)";
    ctx.fill();
    ctx.strokeStyle = "rgba(255,230,160,0.22)";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(x+20, y-2, 10, -Math.PI/2, Math.PI/2);
    ctx.strokeStyle = "rgba(255,230,160,0.22)";
    ctx.lineWidth = 3;
    ctx.stroke();

    ctx.globalAlpha = 0.25;
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 2;
    for (let i=0;i<3;i++){
      ctx.beginPath();
      ctx.moveTo(x-8+i*8, y-22);
      ctx.quadraticCurveTo(x-18+i*8, y-40, x-6+i*8, y-54);
      ctx.stroke();
    }
    ctx.restore();
  }

  function roundRectPath(x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  function render(now, intensity) {
    const shake = state.shake;
    const sx = shake ? rand(-shake, shake) : 0;
    const sy = shake ? rand(-shake, shake) : 0;
    state.shake = Math.max(0, state.shake - 0.9);

    ctx.save();
    ctx.clearRect(0, 0, W, H);
    ctx.translate(sx, sy);

    drawOfficeBackground(now);

    // ground
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fillRect(0, GROUND_Y + 16, W, 2);

    for (const it of issues) drawIssue(it, intensity);
    for (const it of items) drawItem(it);
    drawParticles();
    drawPlayer(now);

    ctx.restore();
  }

  function drawIssue(it, intensity) {
    ctx.save();
    ctx.translate(it.x, it.y);
    ctx.rotate(it.rot);

    ctx.beginPath();
    ctx.arc(0, 0, it.r, 0, Math.PI * 2);
    ctx.fillStyle = it.touched ? "rgba(255,80,80,0.35)" : "rgba(255,255,255,0.12)";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = it.touched ? "rgba(255,110,110,0.55)" : "rgba(255,255,255,0.26)";
    ctx.stroke();

    ctx.rotate(-it.rot);
    ctx.font = `800 ${Math.max(12, Math.floor(it.r * 0.52))}px ui-sans-serif, system-ui, -apple-system, "Apple SD Gothic Neo", "Noto Sans KR"`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    const s = it.word.length > 9 ? it.word.slice(0, 9) + "â€¦" : it.word;
    ctx.fillText(s, 0, 0);

    if (!it.touched) {
      ctx.globalAlpha = 0.10 + intensity * 0.12;
      ctx.beginPath();
      ctx.arc(0, 0, it.r + 10 + intensity * 10, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(255,120,120,1)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawItem(it) {
    if (it.kind !== "coffee") return;

    ctx.save();
    ctx.translate(it.x, it.y);
    ctx.rotate(it.rot);

    ctx.beginPath();
    ctx.arc(0, 0, it.r, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(255,255,255,0.16)";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.stroke();

    ctx.rotate(-it.rot);
    ctx.font = `900 ${Math.floor(it.r * 1.25)}px ui-sans-serif, system-ui, -apple-system, "Apple SD Gothic Neo", "Noto Sans KR"`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.fillText("â˜•", 0, 1);

    ctx.globalAlpha = 0.14;
    ctx.beginPath();
    ctx.arc(0, 0, it.r + 11, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(255,230,160,1)";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.restore();
  }

  function drawParticles() {
    for (const p of particles) {
      const a = 1 - (p.t / p.life);
      ctx.globalAlpha = a * 0.85;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,230,160,1)";
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function drawPlayer(now) {
    const inv = now < player.invulnUntil;
    const invLeft = Math.max(0, player.invulnUntil - now);

    ctx.save();
    ctx.translate(player.x, player.y);

    ctx.beginPath();
    roundRectMini(-player.w/2, -player.h/2, player.w, player.h, 10);
    ctx.fillStyle = inv ? "rgba(255,255,255,0.34)" : "rgba(255,255,255,0.18)";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = inv ? "rgba(255,200,120,0.85)" : "rgba(255,255,255,0.35)";
    ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,0.86)";
    ctx.beginPath(); ctx.arc(-7, -2, 2.1, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( 7, -2, 2.1, 0, Math.PI*2); ctx.fill();
    ctx.beginPath();
    ctx.arc(0, 6, 5, 0, Math.PI, false);
    ctx.strokeStyle = "rgba(255,255,255,0.7)";
    ctx.lineWidth = 1.6;
    ctx.stroke();

    if (input.dash && Math.abs(player.vx) > 1) {
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "rgba(255,255,255,0.20)";
      for (let i=1; i<=3; i++) {
        roundRectMini(-player.w/2 - i*18 * Math.sign(player.vx || 1), -player.h/2, player.w, player.h, 10);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    if (inv) {
      ctx.globalAlpha = 0.18 + 0.12 * Math.sin(now / 60);
      ctx.beginPath();
      ctx.arc(0, 0, 32 + (invLeft/2000)*8, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(255,230,160,1)";
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  function roundRectMini(x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  function drawCenteredText(lines, y0) {
    ctx.save();
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(255,255,255,0.94)";
    lines.forEach((line, i) => {
      ctx.font = (i === 0)
        ? '900 30px ui-sans-serif, system-ui, -apple-system, "Apple SD Gothic Neo", "Noto Sans KR"'
        : '650 18px ui-sans-serif, system-ui, -apple-system, "Apple SD Gothic Neo", "Noto Sans KR"';
      ctx.fillText(line, W/2, y0 + i*34);
    });
    ctx.restore();
  }

  function drawSplash() {
    ctx.clearRect(0, 0, W, H);
    drawOfficeBackground(performance.now());
    ctx.fillStyle = "rgba(0,0,0,0.36)";
    ctx.fillRect(0,0,W,H);
    drawCenteredText(
      ["ì´ìŠˆ íšŒí”¼ 60ì´ˆ â€” HARD", "ì´ˆë°˜ë¶€í„° ë¹¡ì„¸ê²Œ ì˜µë‹ˆë‹¤. ì»¤í”¼ëŠ” í¬ê·€í…œ.", "ì‹œì‘ ë²„íŠ¼ ë˜ëŠ” Enter (ëª¨ë°”ì¼ì€ ë“œë˜ê·¸)"],
      H/2 - 20
    );
  }

  function drawPaused() {
    render(performance.now(), 0.5);
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.42)";
    ctx.fillRect(0,0,W,H);
    drawCenteredText(["ì¼ì‹œì •ì§€", "Pë¡œ ì¬ê°œ"], H/2 - 10);
    ctx.restore();
  }

  function drawEnd(win) {
    render(performance.now(), 1.0);
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.52)";
    ctx.fillRect(0,0,W,H);
    const title = win ? WIN_TITLE : pick(LOSE_TITLES);
    const sub1 = `ì ìˆ˜: ${state.score} | í”¼ê²©: ${state.hits} | ìµœê³ : ${bestScore}`;
    const sub2 = "ì¬ì‹œì‘ ë²„íŠ¼ ë˜ëŠ” R";
    drawCenteredText([title, sub1, sub2], H/2 - 20);
    ctx.restore();
  }

  // ===== Inputs =====
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === "arrowleft" || k === "a") input.left = true;
    if (k === "arrowright" || k === "d") input.right = true;
    if (k === "shift") input.dash = true;

    if (k === "p") togglePause();
    if (k === "enter") start();
    if (k === "r") { reset(); start(); }

    if (["arrowleft","arrowright"," "].includes(k)) e.preventDefault();
  }, { passive: false });

  window.addEventListener("keyup", (e) => {
    const k = e.key.toLowerCase();
    if (k === "arrowleft" || k === "a") input.left = false;
    if (k === "arrowright" || k === "d") input.right = false;
    if (k === "shift") input.dash = false;
  });

  function canvasToGameX(clientX) {
    const rect = canvas.getBoundingClientRect();
    const nx = (clientX - rect.left) / rect.width;
    return clamp(nx * W, 22, W - 22);
  }

  canvas.addEventListener("pointerdown", (e) => {
    ensureAudio();
    canvas.setPointerCapture(e.pointerId);
    input.pointerActive = true;
    input.pointerX = canvasToGameX(e.clientX);
    if (!state.running) start();
  });
  canvas.addEventListener("pointermove", (e) => {
    if (!input.pointerActive) return;
    input.pointerX = canvasToGameX(e.clientX);
  });
  canvas.addEventListener("pointerup", () => { input.pointerActive = false; });
  canvas.addEventListener("pointercancel", () => { input.pointerActive = false; });

  ui.dashBtn.addEventListener("pointerdown", (e) => {
    ensureAudio();
    input.dash = true;
    ui.dashBtn.classList.add("active");
    e.preventDefault();
  }, { passive: false });

  window.addEventListener("pointerup", () => {
    input.dash = false;
    ui.dashBtn.classList.remove("active");
  });

  ui.startBtn.addEventListener("click", start);
  ui.restartBtn.addEventListener("click", () => { reset(); start(); });

  reset();
})();
</script>
</body>
</html>




